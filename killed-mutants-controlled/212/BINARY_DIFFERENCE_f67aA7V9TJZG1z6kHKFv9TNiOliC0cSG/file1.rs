#![allow(warnings, unused, unconditional_panic)]
use std::env;
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
const CONST1: f32 = 0.07890719f32;
const CONST2: u32 = 216467613u32;
const CONST3: u64 = 5238699588795769360u64;
const CONST4: i128 = 53130112494191645964915122210330692308i128;
const CONST5: i128 = 24918952815139486295560296207578654433i128;
const CONST6: u128 = 92432591904242074597405799298032788144u128;
const CONST7: usize = 17572309120036262811usize;
const CONST8: u16 = 9860u16;
const CONST9: i32 = 1787585803i32;
const CONST10: i8 = 81i8;
macro_rules! reconditioned_div{
    ($a:expr,$b:expr, $zero: expr) => {
        {
            let denominator = $b;
            if (denominator != $zero) {($a / denominator)} else {$zero}
        }
    }
}
macro_rules! reconditioned_mod{
    ($a:expr,$b:expr, $zero: expr) => {
        {
            let denominator = $b;
            if (denominator != $zero) {($a % denominator)} else {$zero}
        }
    }
}
#[derive(Debug)]
struct Struct1<'a2> {
var1: &'a2 mut f64,
var2: Option<u128>,
}

impl<'a2> Struct1<'a2> {
  
}
#[derive(Debug)]
struct Struct2 {
var77: u16,
var78: i128,
}

impl Struct2 {
  
}
#[derive(Debug)]
struct Struct3<'a4> {
var116: &'a4 mut Box<i128>,
}

impl<'a4> Struct3<'a4> {
  
}
type Type1 = u32;
type Type2 = (u64,i8,Box<u64>);
#[inline(never)]
fn fun2( var6: u16, var7: &Box<i128>, hasher: &mut DefaultHasher) -> Vec<u8> {
let mut var8: i8 = 23i8;
let mut var11: usize = 7832538778509472019usize;
let var10: &mut usize = &mut (var11);
let var9: &mut usize = var10;
var9;
var8 = 36i8;
var8 = 41i8;
format!("{:?}", var7).hash(hasher);
format!("{:?}", var6).hash(hasher);
(29427u16);
format!("{:?}", var6).hash(hasher);
73386600357922993224617080063075510383i128;
return {
41801441111815224976141033650809244551i128;
let mut var12: u128 = 127918719581273144340410815711929806689u128;
&mut (var12);
let var13: u8 = 246u8;
var8 = 18i8;
132753295682127929462560591459938659278u128;
let var16: f64 = 0.7957722691108707f64;
let var15: f64 = var16;
let var14: f64 = var15;
var14;
let var19: u8 = 55u8;
let var18: u8 = var19;
let var17: Vec<u8> = vec![var18];
return var17;
let var22: u8 = 65u8;
let var21: u8 = var22;
let var23: u8 = 250u8;
let var24: u8 = 153u8;
let var20: Vec<u8> = vec![var21,175u8,var23,59u8,var24,132u8,79u8];
var20
};
let var59: Option<bool> = Some::<bool>(true);
let var58: bool = match (var59) {
None => {
let var65: Vec<u128> = vec![68617360641149902246939612596898089122u128,7870996683919189082378567499652425509u128,80611588114629442923080710531243210489u128,139439719320228176478849753827159903745u128,64095234284959026333153679496343097688u128,133043084898011608755535827961212597617u128,75305356937886250926459084109317256081u128];
var65;
let var66: i32 = -994132250i32;
var66;
let var67: i64 = -5150857442380527328i64;
let var72: u8 = 21u8;
var72;
var8 = 82i8;
var8 = CONST10;
format!("{:?}", var66).hash(hasher);
let mut var73: u8 = 170u8;
let mut var74: u8 = (139u8);
let mut var75: u8 = 101u8;
let var76: u8 = reconditioned_div!(35u8, 200u8, 0u8);
vec![var73,239u8,106u8,var74,16u8,var75].push(var76);
var73 = 136u8;
format!("{:?}", var73).hash(hasher);
Struct2 {var77: 48055u16, var78: 169392560591648313889087514976316870644i128,};
let var79: Vec<u8> = vec![(167u8),186u8,252u8,38u8,13u8,146u8,63u8,245u8];
return var79;
let var80: bool = true;
var80},
 Some(var60) => {
let var61: i32 = 216741305i32;
var61;
let var62: u16 = 2323u16;
let var63: Vec<u8> = vec![121u8,122u8,49u8,123u8,157u8,31u8,(151u8 & 196u8),209u8];
return var63;
let var64: bool = (12262046951621609040u64 <= 18277173552826235474u64);
var64
}
}
;
let var57: bool = var58;
if (var57) {
 let var26: i64 = -8020963994303145524i64;
let mut var25: i64 = var26;
let var28: i64 = -3196870405003083428i64;
let var27: i64 = var28;
let var31: u8 = 216u8;
let var32: u8 = 187u8;
let var33: u8 = 225u8;
let var38: u8 = 167u8;
let var37: u8 = var38;
let var36: u8 = var37;
let var35: u8 = var36;
let var34: u8 = var35;
let var40: u8 = 245u8;
let var39: u8 = var40;
let var41: u8 = 94u8;
let var30: Vec<u8> = vec![var31,var32.wrapping_sub(143u8),var33,114u8,87u8,var34.wrapping_sub(var39),var41];
let var29: Vec<u8> = var30;
return var29;
let var42: u8 = 156u8;
let var45: u8 = 236u8;
let var44: u8 = var45;
let var43: u8 = var44;
let var46: u8 = 161u8;
let var49: u8 = 179u8;
let var48: u8 = var49;
let var47: u8 = var48;
let var50: u8 = 119u8;
let var51: u8 = 74u8;
let var52: u8 = 48u8;
let var53: u8 = 241u8;
let var56: u8 = 19u8;
let var55: u8 = var56;
let var54: u8 = var55;
vec![var42,var43,var46,var47,var50,var51,var52,var53,var54] 
} else {
 var8 = 59i8;
let var84: u8 = 153u8;
let var83: u8 = var84;
let var85: u8 = 241u8;
let var90: u8 = 86u8;
let var89: u8 = var90;
let var88: u8 = var89;
let var87: u8 = var88;
let var86: u8 = var87;
let var93: u8 = 213u8;
let var92: u8 = var93;
let var91: u8 = var92;
let var82: Vec<u8> = vec![var83,var85,247u8,var86,var91,115u8,5u8];
let var81: Vec<u8> = var82;
return var81;
let var94: u8 = 248u8;
let var96: u8 = 144u8;
let var95: u8 = var96;
let var109: bool = true;
let var108: bool = var109;
let var99: u8 = if (var108) {
 let var101: u64 = 10666581054615711671u64;
&(var101);
let var102: String = String::from("RDIvoZyZd3pYaJOAjxVMzbXGvlJmlHrHienXsYtCYShdn44eov5NgUHZHa7XYyusPYjDHm0tYHticsR2fGKOjgI");
121039305232302910813179320370993760797i128;
format!("{:?}", var90).hash(hasher);
let var103: u8 = 14u8;
let var104: u8 = 134u8;
let var105: u8 = 200u8;
let var106: u8 = 171u8;
return vec![var103,var104,var105,178u8,var106,155u8];
let var107: u8 = 205u8;
var107 
} else {
 let var101: u64 = 10666581054615711671u64;
&(var101);
let var102: String = String::from("RDIvoZyZd3pYaJOAjxVMzbXGvlJmlHrHienXsYtCYShdn44eov5NgUHZHa7XYyusPYjDHm0tYHticsR2fGKOjgI");
121039305232302910813179320370993760797i128;
format!("{:?}", var90).hash(hasher);
let var103: u8 = 14u8;
let var104: u8 = 134u8;
let var105: u8 = 200u8;
let var106: u8 = 171u8;
return vec![var103,var104,var105,178u8,var106,155u8];
let var107: u8 = 205u8;
var107 
};
let var98: u8 = var99;
let var97: u8 = var98;
vec![var94,var95,var97,157u8] 
}
}


fn fun3( hasher: &mut DefaultHasher) -> i64 {
46849u16;
return 1602553207357689812i64;
3190471406273073140i64
}

#[inline(never)]
fn fun4( var129: bool, var130: &Struct2, var131: Box<i128>, hasher: &mut DefaultHasher) -> Box<i128> {
();
0.330800883941062f64;
let mut var134: u32 = 3726821875u32;
var134 = 1603841989u32;
format!("{:?}", var130).hash(hasher);
let var137: f32 = 0.99609834f32;
var137;
let var139: i8 = 108i8;
let var138: i8 = var139;
let mut var140: u128 = 15261716479063234010235688794049247282u128;
let mut var141: u128 = 104896724390405477745801619902072371246u128;
let mut var142: u128 = 105604514974500784377214373835199270103u128;
let var143: u128 = 32372264132351862533889416018926127769u128;
vec![84099062499121002958409527403880077878u128,66113407415157257086896709481644366133u128,27940334448464781916089872900470680719u128,23569919320276286744940384913931368342u128,106891689571376020716340333587026536231u128,var140,119562500514118990407950106587580891546u128,var141,var142].push(var143);
format!("{:?}", var129).hash(hasher);
var134 = 1713211062u32;
true;
var134 = 2777410598u32;
var141 = CONST6;
let var144: String = String::from("mb9ohJ3scKQTPkwZjIZ9S4l5LEbvjDwXlpUk48LyvV96gJ8kCTmjknQ5Sf2Ia9jAs0DOqxQ9bEcQy9P3JZCSs73NinVgp9");
&(var144);
let var145: Vec<u128> = vec![65449469846746992912768641019829931432u128,127949096476662963824610274847969521716u128,43565319408489402061488576452748297254u128,118191480268859659159626814836873827439u128,90904825008629091889225790968951997868u128,134039409044337310619104856084309839351u128,85172774797385680119863523890115810703u128.wrapping_add(58568395571353312569940344059124504543u128),111302560759290685712231547193817648876u128];
(var145);
3142525176494447477u64;
16765817276143276219u64;
let var146: u64 = 11908258629158615949u64;
Box::new(var146);
let var148: Type1 = 3434614272u32;
let mut var147: Type1 = var148;
var134 = var148;
let var149: u128 = 169736635172515570934144729970447948545u128;
var149;
21181i16;
var140 = CONST6;
let var150: Box<i128> = Box::new(168880205396420326436441467004973592351i128);
return var150;
let var151: Box<i128> = Box::new(28193788439186628423326991977831758701i128);
var151
}


fn fun1( var5: u8, hasher: &mut DefaultHasher) -> i8 {
let var155: i16 = 27924i16;
let var154: i16 = var155;
let mut var153: i16 = var154;
&mut (var153);
format!("{:?}", var155).hash(hasher);
let var157: String = String::from("5lKqODuNryL35vPn95Dq7OXonisVvjivDzebF7DmUyx");
let mut var156: String = var157;
let var159: String = String::from("nY9WLf1Ztofk");
let var158: String = var159;
var156 = var158;
let var161: u64 = 11587354769198215212u64;
let var160: (u64,i8,Box<u64>) = (var161,51i8,Box::new(13908426564029930651u64));
var160;
let var163: u128 = {
let var164: i8 = 81i8;
return var164;
55198578350091505000556555618083893857u128
};
let var162: u128 = (var163);
var162;
78u8;
format!("{:?}", var155).hash(hasher);
let var165: String = String::from("5qQnEBRkUbBhYEXRZQVqLJdnAqsCE7ETEeoubH7h81vlpU6FWSWjZjTYDj2wY2wMdlbU8SR6PjzOju2fwRolIjJdyCoyQI0No94");
var156 = var165;
format!("{:?}", var163).hash(hasher);
return 59i8;
let var168: i8 = 14i8;
let var167: i8 = var168;
let var166: i8 = var167;
var166
}


fn fun5( var182: u8, var183: String, var184: u32, hasher: &mut DefaultHasher) -> i32 {
let var186: f64 = 0.4279020569414165f64;
let mut var185: f64 = var186;
let mut var187: Box<u8> = Box::new(57u8);
&mut (var187);
let var193: u8 = 56u8;
let var194: u8 = 195u8;
let var192: Vec<u8> = vec![102u8,var193,var194];
let var191: Vec<u8> = var192;
let var190: Vec<u8> = var191;
let var189: Vec<u8> = var190;
let mut var188: Vec<u8> = var189;
var188.push(5u8);
let var195: f32 = 0.9970147f32;
var195;
var185 = var186;
let var197: i32 = -1864664172i32;
let var196: i32 = reconditioned_mod!(var197, -753451344i32, 0i32);
return (*Box::new(var196));
-33446515i32
}


fn main( ) -> () {
let cli_args: Vec<String> = env::args().collect();
let mut s = DefaultHasher::new();
let hasher = &mut s;
let mut var3: Option<bool> = None::<bool>;
format!("{:?}", var3).hash(hasher);
let mut var4: i8 = fun1(81u8,hasher).wrapping_mul(81i8);
let var173: f64 = cli_args[1].clone().parse::<f64>().unwrap();
let var172: &f64 = &(var173);
let var171: &f64 = var172;
let var170: &f64 = var171;
let var169: f64 = (*var170);
var169;
();
var3 = None::<bool>;
var4 = 12i8;
let var174: f64 = cli_args[1].clone().parse::<f64>().unwrap();
&(var174);
(7i8 ^ 74i8);
var4 = 51i8;
cli_args[2].clone().parse::<u64>().unwrap();
let var175: i32 = -1871031051i32;
var175;
format!("{:?}", var169).hash(hasher);
let mut var176: f32 = cli_args[3].clone().parse::<f32>().unwrap();
format!("{:?}", var3).hash(hasher);
let var177: i16 = cli_args[4].clone().parse::<i16>().unwrap();
let var178: u32 = 3839544162u32;
let var181: i8 = 78i8;
let var180: i8 = var181;
let mut var179: i8 = var180;
fun5(cli_args[5].clone().parse::<u8>().unwrap(),cli_args[6].clone().parse::<String>().unwrap(),329311383u32,hasher);
let var199: i64 = -1003454833992811915i64;
let var198: i64 = var199;
var198;
format!("{:?}", CONST1).hash(hasher);
format!("{:?}", CONST10).hash(hasher);
format!("{:?}", CONST2).hash(hasher);
format!("{:?}", CONST3).hash(hasher);
format!("{:?}", CONST4).hash(hasher);
format!("{:?}", CONST5).hash(hasher);
format!("{:?}", CONST6).hash(hasher);
format!("{:?}", CONST7).hash(hasher);
format!("{:?}", CONST8).hash(hasher);
format!("{:?}", CONST9).hash(hasher);
format!("{:?}", var169).hash(hasher);
format!("{:?}", var170).hash(hasher);
format!("{:?}", var171).hash(hasher);
format!("{:?}", var172).hash(hasher);
format!("{:?}", var175).hash(hasher);
format!("{:?}", var176).hash(hasher);
format!("{:?}", var177).hash(hasher);
format!("{:?}", var178).hash(hasher);
format!("{:?}", var179).hash(hasher);
format!("{:?}", var180).hash(hasher);
format!("{:?}", var181).hash(hasher);
format!("{:?}", var198).hash(hasher);
format!("{:?}", var199).hash(hasher);
format!("{:?}", var3).hash(hasher);
format!("{:?}", var4).hash(hasher);
println!("Program Seed: {:?}", 7147099145085795513i64);
println!("{:?}", hasher.finish());
}
